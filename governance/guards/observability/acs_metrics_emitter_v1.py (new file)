#!/usr/bin/env python3
# TruthSeal™ Observability — ACS Metrics Emitter v1
# Reads counters from METRICS_INPUT_JSON and prints:
#   METRIC Purity <val> <unix_ts>
#   METRIC SelfRegulation <val> <unix_ts>
#   METRIC TemporalDrift <val> <unix_ts>
#   METRIC ACS <val> <unix_ts>
# Values are clamped to [0,1] and script never hard-fails.

import os, sys, json, time, math

def _clamp01(x):
    try:
        x = float(x)
    except Exception:
        x = 0.0
    if x < 0.0: return 0.0
    if x > 1.0: return 1.0
    return x

def _norm(x, lo=0.0, hi=10.0):
    try:
        x = float(x)
    except Exception:
        x = 0.0
    if hi <= lo:
        return 0.0
    y = (x - lo) / (hi - lo)
    return _clamp01(y)

def _safe(d, k, default=0.0):
    try:
        return float(d.get(k, default))
    except Exception:
        return float(default)

def compute_indices(c):
    # Safe inputs with very defensive defaults
    redactions   = _safe(c, "Commander_Output_Redaction_Rate", 0.0)     # [0..1]
    evl_mismatch = _safe(c, "EVL_Hash_Mismatch_Count", 0.0)              # 0..n
    blocked      = _safe(c, "Blocked_HighRisk_Jobs", 0.0)                # 0..n
    detected     = _safe(c, "Detected_HighRisk_Jobs", 0.0)               # 0..n
    reversal     = _safe(c, "Reversal_Edits_Rate", 0.0)                  # [0..1]
    crumbs_miss  = _safe(c, "Missing_Breadcrumbs_Rate", 0.0)             # [0..1]

    # Simple, explainable draft formulas (tune later)
    purity_penalty = _norm(redactions*10.0 + evl_mismatch + crumbs_miss*10.0, 0.0, 20.0)
    purity = _clamp01(1.0 - purity_penalty)

    # Self-regulation improves when more risky jobs are blocked (and fewer reversals/redactions)
    block_eff = _clamp01(0.5 + 0.5 * (blocked - detected) / (1.0 + blocked + detected))
    self_reg  = _clamp01(0.5*block_eff + 0.25*(1.0 - reversal) + 0.25*(1.0 - redactions))

    # Temporal drift is low when EVL mismatches & breadcrumbs issues are low
    drift = _clamp01(1.0 - _norm(evl_mismatch + crumbs_miss*10.0, 0.0, 20.0))

    # Aggregate ACS: balanced mean of the three
    acs = _clamp01((purity + self_reg + drift) / 3.0)

    return {"purity": purity, "self_reg": self_reg, "drift": drift, "acs": acs}

def main():
    path = os.environ.get("METRICS_INPUT_JSON", "").strip()
    data = {}
    if path and os.path.exists(path):
        try:
            with open(path, "r", encoding="utf-8") as f:
                data = json.load(f)
        except Exception as e:
            print(f"::warning title=metrics::Failed to read {path}: {e}")
    else:
        print(f"::warning title=metrics::Input missing; using safe defaults ({path})")
        data = {
            "EVL_Hash_Mismatch_Count": 0,
            "Commander_Output_Redaction_Rate": 0,
            "Blocked_HighRisk_Jobs": 4,
            "Detected_HighRisk_Jobs": 5,
            "Reversal_Edits_Rate": 0,
            "Missing_Breadcrumbs_Rate": 0
        }

    m = compute_indices(data)
    ts = int(time.time())
    print(f"METRIC Purity {m['purity']:.2f} {ts}")
    print(f"METRIC SelfRegulation {m['self_reg']:.2f} {ts}")
    print(f"METRIC TemporalDrift {m['drift']:.2f} {ts}")
    print(f"METRIC ACS {m['acs']:.2f} {ts}")
    return 0

if __name__ == "__main__":
    try:
        sys.exit(main())
    except Exception as e:
        print(f\"::error title=metrics::Unhandled error: {e}\")
        sys.exit(0)
